[bits 32]

VGA_WIDTH   equ 80
VGA_HEIGHT  equ 25

global term_buffer
global term_col
global term_row
global _term_init:function (_term_init.end - _term_init)                        ; void _term_init(void)
global _term_setcolor:function (_term_setcolor.end - _term_setcolor)            ; void _term_setcolor(char)
global _term_putentryat:function (_term_putentryat.end - _term_putentryat)      ; void _term_putentryat(char, char, dword, dword)
global _term_putchar:function (_term_putchar.end - _term_putchar)               ; void _term_putchar(char)
global _term_write:function (_term_write.end - _term_write)                     ; void _term_write(char*, dword)
global _term_writestring:function (_term_writestring.end - _term_writestring)   ; void _term_writestring(char*)

extern _strlen                                          ; near


SECTION .text   align=16
; Function _term_init: Initialize terminal
_term_init:; Function begin
        mov     dword [term_row], 0                     ; term_row = 0
        mov     dword [term_col], 0                     ; term_col = 0
        mov     byte [term_color], 7                    ; bg - 0(black), fg - 7(grey)
        mov     dword [term_buffer], 753664             ; [term_buffer] becoming origin or video mem
        movzx   edx, byte [term_color]                  ; set edx := term_color
        mov     eax, 753664                             ; 0xB8000 - hardware video memory
        shl     edx, 8                                  ; edx ([term_color]) << 8
        or      edx, 0x20                               ; 0x20=' '

.L1:    mov     word [eax], dx                          ; [eax] = ' '|bgfg
        add     eax, 2                                  ; 1 buffer = 1 word (2 byte)
        cmp     eax, 757664                             ; 80*25*2byte = 4000byte + origin
        jne     .L1

        ret
.end:
; term_init End of function


; Function _term_setcolor: Set terminal background and foreground color (fg | bg << 4)
_term_setcolor:; Function begin
        mov     eax, dword [esp+4]
        mov     byte [term_color], al

        ret
.end:
; term_setcolor End of function


;ALIGN   8
; Function _term_putentryat: Write an entry to terminal buffer
_term_putentryat:; Function begin
        movzx   edx, byte [esp+8]                               ; color
        shl     edx, 8
        or      edx, byte [esp+4]                               ; c
              
        mov     eax, dword [esp+16]                             ; y
        mul     VGA_WIDTH                                       ; y * 80
        add     eax, dword [esp+12]                             ; + x
        
        ;lea     eax, [eax+eax*4]
        ;mov     ecx, edx
        ;movzx   edx, byte [esp+0x4]
        ;shl     ecx, 8
        ;shl     eax, 4
        ;add     eax, dword [esp+0x0C]
        ;or      edx, ecx
        
        mov     ecx, dword [term_buffer]
        mov     word [ecx+eax*2], dx                            ; 2 byte per buffer

        ret
.end:
; term_putentryat End of function

;ALIGN   8
; Function _term_putchar: write a char into terminal buffer
_term_putchar:; Function begin
        push    ebp
        mov     ebp, esp
        
        ; Call _term_putentryat
        mov     eax, dword [term_row]                           ; y
        push    eax
        mov     eax, dword [term_col]                           ; x
        push    eax
        movzx   eax, byte [term_color]
        push    eax
        movzx   eax, byte [ebp+8]                               ; c
        call    _term_putentryat
        add     esp, 16
        
        mov     eax, dword [term_col]                           ; if (++term_col == 80)
        inc     eax
        cmp     eax, VGA_WIDTH
        jne     .leave
        mov     dword [term_col], 0                             ; term_col = 0
        
        ; TODO: if reaching end of buffer, pop buffer top line into history, shift remaining
        ;       lines 1 row up.
        mov     eax, dword [term_row]                           ; if (++term_row == 25)
        inc     eax
        cmp     eax, VGA_HEIGHT
        jne     .leave
        mov     dword [term_row], 0                             ; term_col = 0
        
        push    esi
        push    ebx
        movzx   ebx, byte [term_color]
        mov     esi, ebx
        movzx   ebx, byte [ebp+8]
        mov     ecx, dword [term_row]
        mov     edx, dword [term_col]
        cmp     ebx, 10
        jne     .x
        add     ecx, 1
        mov     dword [term_col], 0
        pop     ebx
        mov     dword [term_row], ecx
        pop     esi
        leave
        ret        
.x:     lea     eax, [ecx+ecx*4]
        shl     esi, 8
        shl     eax, 4
        add     eax, edx
        add     edx, 1
        or      ebx, esi
        mov     esi, dword [term_buffer]
        cmp     edx, 80
        mov     word [esi+eax*2], bx
        jz      .L2
        pop     ebx
        mov     dword [term_col], edx
        pop     esi
 
.leave       
        leave
        ret
.end

ALIGN   16
.L2:    add     ecx, 1
        mov     eax, 0
        mov     dword [term_col], 0
        cmp     ecx, 25
        cmove   ecx, eax
        pop     ebx
        mov     dword [term_row], ecx
        pop     esi
        
        leave
        ret
.end:
; term_putchar End of function

        jmp     _term_write                             ; 0101 _ EB, 0D

        nop                                             ; 0103 _ 90
        nop                                             ; 0104 _ 90
        nop                                             ; 0105 _ 90
        nop                                             ; 0106 _ 90
        nop                                             ; 0107 _ 90
        nop                                             ; 0108 _ 90
        nop                                             ; 0109 _ 90
        nop                                             ; 010A _ 90
        nop                                             ; 010B _ 90
        nop                                             ; 010C _ 90
        nop                                             ; 010D _ 90
        nop                                             ; 010E _ 90
        nop                                             ; 010F _ 90

ALIGN   16
_term_write:; Function begin
        push    ebp
        mov     ebp, esp
        
        push    esi                                     ; 0110 _ 56
        push    ebx                                     ; 0111 _ 53
        mov     esi, dword [esp+0x10]                   ; 0112 _ 8B. 74 24, 10
        test    esi, esi                                ; 0116 _ 85. F6
        jz      .L4                                     ; 0118 _ 74, 17
        mov     ebx, dword [esp+0x0C]                    ; 011A _ 8B. 5C 24, 0C
        add     esi, ebx                                ; 011E _ 01. DE
.L3:    movsx   eax, byte [ebx]                         ; 0120 _ 0F BE. 03
        add     ebx, 1                                  ; 0123 _ 83. C3, 01
        push    eax                                     ; 0126 _ 50
        call    _term_putchar                           ; 0127 _ E8, FFFFFFFC(rel)
        add     esp, 4
        cmp     esi, ebx                                ; 012C _ 39. DE
        ;pop     eax                                     ; 012E _ 58
        jnz     .L3                                     ; 012F _ 75, EF
.L4:    pop     ebx                                     ; 0131 _ 5B
        pop     esi                                     ; 0132 _ 5E

        leave
        ret                                             ; 0133 _ C3
.end:        
; term_write End of function

ALIGN   16
_term_writestring:; Function begin
        push    ebp
        mov     ebp, esp
        
        push    esi
        push    ebx
        mov     ebx, dword [ebp+8]
        push    ebx                                     ; 0149 _ 53
        call    _strlen                                 ; 014A _ E8, FFFFFFFC(rel)
        add     esp, 4                                  ; 014F _ 83. C4, 10
        test    eax, eax                                ; 0152 _ 85. C0
        jz      .L6                                     ; 0154 _ 74, 20
        lea     esi, [ebx+eax]                          ; 0156 _ 8D. 34 03

ALIGN   8
.L5:    movsx   edx, byte [ebx]
        add     ebx, 1
        push    edx
        call    _term_putchar
        add     esp, 4
        cmp     esi, ebx
        jnz     .L5
.L6:
        mov     edx, 56H
        push    edx
        call    _term_putchar
        add     esp, 4
        
        pop     ebx
        pop     esi
        
        leave
        ret
.end:
; term_writestring End of function


SECTION .data   align=1                                 ; section number 2, data


SECTION .bss    align=1                                 ; section number 3, bss
term_color:
        resb 1
term_buffer:
        resd 1
term_col:
        resw 1
term_row:
        resw 1
